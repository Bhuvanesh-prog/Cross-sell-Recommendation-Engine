"""Lightweight loader that surfaces product-to-product recommendations."""
from __future__ import annotations

import json
from threading import Lock
from typing import Dict, List

from ..config import LakehousePaths
from ..data.gold import GOLD_TABLES


class RecommendationIndex:
    """Caches similarity results generated by the pipeline for fast lookup."""

    def __init__(self, lakehouse: LakehousePaths) -> None:
        self._item_similarity_path = lakehouse.gold / GOLD_TABLES["item_similarity"]
        self._lock = Lock()
        self._cache: List[Dict[str, object]] = []
        self._stamp: float = -1.0

    def _refresh_cache(self) -> None:
        if not self._item_similarity_path.exists():
            self._cache = []
            self._stamp = -1.0
            return

        current_stamp = self._item_similarity_path.stat().st_mtime
        if current_stamp == self._stamp:
            return

        with self._item_similarity_path.open() as handle:
            self._cache = json.load(handle)
        self._stamp = current_stamp

    def recommendations_for(self, product_id: str, limit: int) -> List[Dict[str, object]]:
        with self._lock:
            self._refresh_cache()
            rows = [row for row in self._cache if row.get("product_id") == product_id]
        return rows[:limit]

    def available_products(self) -> List[str]:
        with self._lock:
            self._refresh_cache()
            return sorted({row.get("product_id") for row in self._cache if row.get("product_id")})
